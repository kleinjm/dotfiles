# frozen_string_literal: true

# == Schema Information
#
# Table name: escrows
#
#  id                      :bigint           not null, primary key
#  address                 :string           not null
#  address2                :string
#  city                    :string
#  closes_on               :date
#  closes_on_tbd           :boolean          default(FALSE), not null
#  customers_count         :integer          default(0)
#  demo_mode               :boolean          default(FALSE), not null
#  name                    :string
#  open                    :boolean          default(TRUE), not null
#  reference               :string           not null
#  state                   :string
#  status                  :string           default("pending"), not null
#  uuid                    :uuid             not null
#  verifiable_contact_type :string
#  zip                     :string
#  created_at              :datetime         not null
#  updated_at              :datetime         not null
#  officer_id              :bigint           not null
#  organization_id         :bigint           not null
#  verifiable_contact_id   :bigint
#
# Indexes
#
#  index_escrows_on_closes_on           (closes_on)
#  index_escrows_on_officer_id          (officer_id)
#  index_escrows_on_organization_id     (organization_id)
#  index_escrows_on_uuid                (uuid) UNIQUE
#  index_escrows_on_verifiable_contact  (verifiable_contact_type,verifiable_contact_id)
#
# Foreign Keys
#
#  fk_rails_...  (officer_id => people.id)
#  fk_rails_...  (organization_id => organizations.id)
#
class Escrow < ApplicationRecord
  include AddressNormalization
  include Uuidable

  paginates_per 10

  has_paper_trail(meta: { organization_id: :organization_id })

  belongs_to :organization

  has_one :passphrase, dependent: :restrict_with_error
  has_many :customers, class_name: 'Customer', dependent: :destroy, counter_cache: true, inverse_of: false
  has_many :statement_of_infos, dependent: :destroy
  has_one :property, dependent: :destroy
  has_many :legal_entities, dependent: :destroy

  belongs_to :officer, class_name: 'Person'
  belongs_to :verifiable_contact, polymorphic: true, optional: true

  has_many :activities, class_name: 'EscrowActivity', dependent: :destroy

  delegate :words, to: :passphrase, prefix: true
  delegate :track_activity, :track_activity_once, to: :activities_log

  scope :open, -> { where(open: true) }
  scope :closed, -> { where(open: false) }
  scope :closes_on_not_passed, -> { where(closes_on: Date.current..).or(where(closes_on_tbd: true)) }
  scope :closes_on_passed, -> { where(closes_on: ...Date.current) }

  READONLY_FIELDS_AFTER_START = %w[
    demo_mode reference address address2 city state zip street_number route
  ].freeze
  STATUSES = {
    pending: 'pending',
    in_progress: 'in_progress',
    complete: 'complete',
    failed: 'failed'
  }.freeze

  STATUSES.each_key do |status_key|
    # Status predicate methods, ie. escrow.pending?, escrow.in_progress?, etc.
    define_method("#{status_key}?") do
      status == STATUSES[status_key]
    end
    # Scope for each status
    define_singleton_method(status_key.to_s) do
      where(status: STATUSES[status_key])
    end
  end

  validates :reference, :address,
            presence: true
  validates :closes_on, presence: true, unless: :closes_on_tbd?
  validate :closes_on_and_tbd_mutually_exclusive

  validate if: :officer_id_changed? do
    next if !officer_id? || !organization_id?

    unless organization.people.find_by(id: officer_id)
      errors.add(:officer_uuid,
                 'is either invalid or from another organization')
    end
  end

  validate if: :lock_important_fields? do
    (changes.keys & READONLY_FIELDS_AFTER_START).each { |f| errors.add(f, "can't be changed") }
  end

  validates :status, inclusion: { in: STATUSES.values }

  def self.lookup!(id)
    if id.is_a?(String) && id =~ /^\w+-\w+-\w+-\w+-\w+$/
      find_by!(uuid: id)
    else
      find(id)
    end
  end

  def self.search(base_query: Escrow.all, query: nil, officer_uuid: nil, status: EscrowsQuery::DEFAULT_STATUS)
    EscrowsQuery.new(base_query:).search(query:, officer_uuid:, status:)
  end

  def to_s
    reference
  end

  def ensure_passphrase!
    Passphrase.for_assignment.first!.update!(escrow: self) unless passphrase?
  end

  def refresh_status!
    with_lock do
      # :: required to avoid Escrow::Customer namespace conflict
      customers_statuses = ::Customer.where(escrow: self).pluck(:status).uniq
      new_status ||= STATUSES[:pending] if customers_statuses.blank? || customers_statuses == [STATUSES[:pending]]
      new_status ||= STATUSES[:failed] if customers_statuses.include?(STATUSES[:failed])
      new_status ||= STATUSES[:complete] if customers_statuses == [STATUSES[:complete]]
      new_status ||= STATUSES[:in_progress]
      raise customers_statuses.inspect unless new_status

      update!(status: new_status) if status != new_status
    end
    self
  end

  def lock_important_fields?
    !new_record? && status != STATUSES[:pending]
  end

  def activities_log
    @activities_log ||= EscrowActivitiesLog.new(self)
  end

  def officer?
    officer_id?
  end

  def officer_uuid=(ouuid)
    self.officer = Person.find_by(uuid: ouuid)
  end

  def officer_uuid
    officer&.uuid
  end

  def passphrase?
    passphrase.present?
  end

  def within_customer_access_period?
    return true if closes_on_tbd?

    closes_on >= 14.days.ago.utc.to_date
  end

  # The passphrase can be viewed by an officer or a buyer.
  # If a buyer viewed the passphrase, it is tracked as a buyer activity and the buyer is linked to the activity.
  # If an officer viewed the passphrase, it is tracked as an officer activity and the buyer is not linked to the activity,
  #  ie. there can be multiple buyers.
  def track_passphrase_view(viewer:, user_session:, buyer: nil)
    timestamp = passphrase.views.create!(viewer:, user_session:).created_at
    category = viewer.is_a?(Buyer) ? :buyer : :officer
    track_activity(category, :viewed_passphrase, timestamp:, whodunnit: viewer, customer: buyer)
  end

  def buyers
    # :: required to avoid Escrow::Customer namespace conflict
    ::Customer.where(escrow: self, type: 'Buyer').order(:id)
  end

  def build_buyer
    Buyer.new(escrow: self)
  end

  # TODO: Rename to buyers_wire_deadline
  def buyer_wire_deadline
    deadline = closes_on - 2.days
    deadline.on_weekday? ? deadline : deadline.prev_weekday
  end

  def sellers
    # :: required to avoid Escrow::Customer namespace conflict
    ::Customer.where(escrow: self, type: 'Seller').order(:id)
  end

  def buyer_legal_entities
    legal_entities.buyers
  end

  def seller_legal_entities
    legal_entities.sellers
  end

  # TODO: Rename to sellers_funds_disbursement_submission_deadline
  def seller_bal_deadline
    deadline = closes_on - 2.days
    deadline.on_weekday? ? deadline : deadline.prev_weekday
  end

  def closes_on_passed?
    return false if closes_on_tbd?

    closes_on < Date.current
  end

  private

  def closes_on_and_tbd_mutually_exclusive
    return unless closes_on.present? && closes_on_tbd?

    errors.add(:closes_on, 'cannot be set when Close Of Escrow is yet to be defined')
    errors.add(:closes_on_tbd, 'cannot be set when Close Of Escrow is defined')
  end
end
